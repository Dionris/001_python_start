#  Множества

# создание

a = {1, 2, 3, 4, 3, 5, 2, 1}  # удаляет повторные значения
b = {'hi', 'ha', 'he', 'ha', 'ho', 'hi', 'he', 'ho'}
c = set('abccdasfbca')  # создали множество из строки
d = set([1, 2, 3, 3, 2, 4, 1])  # создали множества из списка
e = set(range(5))  # создаем из функции range
f = set()  # пустое множество

g = {}  # так НЕЛЬЗЯ, множество станет словарем
# Еще ммножества нельзя делать из списков, так как они изменяются, а множество не может изменяться

print(a, type(a))
print(b, type(b))
print(c, type(c))
print(d, type(d))
print(e, type(e))
print(f, type(f))

print(g, type(g))

# Пример
print('\n Пример')
# нужно из списка убрать все дубликаты
h = [1, 3, 2, 4, 5, 2, 3, 5, 3, 1, 4, 3, 2]
h = list(set(h))
print(h)

# Добавление элемента
print('\n Добавление элемента')
p = {52, 32, 54, 3, 4, 2}
p.add(9)  # видим что элемент добавился в множество
p.add(4)  # видим что такой элемент уже есть во множестве и он второй раз не добавился
p.update([5, 6, 7, 3, 9])  # когда нужно добавить несколько значений
p.update('hello')
p.update(range(5, 10))
p.update({5, 6, 4})

print(p)

# Удаление элемента
print('\nУдаление элемента')
s = {54, 32, 54, 3, 4, 2}
s.discard(4)  # не вызовет ошибку при удалении элемента которго нету в множестве
s.remove(3)  # выдаст ошибку если удалить элемент которого нету
s.pop()  # удаляет случайный элемент , изза того что множество не упорядоченное, а метод 'pop' - удаляет последний элемент

print(s)

s.clear()  # очищает полностью множество

print(s)

# Операции над множеством
print('\n Операции над множеством:')

print('\n Нахождения длины')
v = {54, 32, 54, 3, 4, 2}

print(len(v))

print('\n Есть ли элемент в множестве')
print(4 in v, 7 in v, 7 not in v)  # not - меняет на противоположное (нету ли)

print('\n Есть ли одинаковые множества между двух множеств')
s = {4, 3, 2, 1}
t = {3, 4, 5, 6, 7}

print(s & t)
print(s.intersection(t))  # одно и тоже что и '&'
print(s, t)

print('\n Проверяет и перезаписывает значения из двух множеств')
s &= t

print(s, t)

s.intersection_update(t)  # тоже самое что и '&='
print(s, t)

print('\n Объединение множеств')
v = {4, 3, 2, 1}
w = {3, 4, 5, 6, 7}
x = {1, 2, 3, 4, 10, 11, 12}
y = {3, 6, 7, 3, 6, 3, 5, 4, 3}

print(v | w)
print(v.union(w))  # тоже самое но только метод

print(v)  # v - не изменилось
v = v.union(w)
v |= w  # тоже самое
print(v)  # v - изменилось

print('\n вычетание множеств')
print(v - w)  # но само множество не меняется
print(w - v)

v -= w  # а вот теперь множество поменяется
print(v)

print('\n симетричная разность - все элементы проме одинаковых')
print(w ^ x)

print('\n Можно сравнить между собой')
print(v == w)
print(y == w)

print('\n Можно сравнить входит множество в другое множество или нет')
print(x > v)
print(v > x)

print('\n Элементы множества можно обходить')
for i in w:
    print(i)

# print(w[1])  # по индексу вот так НЕЛЬЗЯ обходить - будет ошибка

# ПРИМЕР:
texter = input()
z = set()
while texter != '':  # наша программа будет работать до того момента пока мы не введем пустую строку
    print(texter.split())  # делит нашу строку поп пробелам
    slova = texter.split()
    z.update(slova)
    print(z)
    texter = input()
print(len(z))
