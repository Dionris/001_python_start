# Рекурсия часть 2

# Пример 1
print('\n Пример 1:')


# входное: ssssdddd
# выходное: s(s(s(sd)d)d)d

def rec(s):
    if len(s) == 1 or len(s) == 2:  # если наша строка равна 1 или 2 символа
        return s  # то выводим эту строку
    return s[0] + '(' + rec(s[1:-1]) + ')' + s[-1]  # а если не равна 1 или 2 символа тогда берем отсоединяем первый
    # и последний символ от нее с тавим скобочки и идем во внутрь с двух сторон обрабатывать следующие символы
    # s[1:-1] - обошли первый и последний символ
    # s[0] + '(' - отщепнули первый символ и поставили скобочку
    # ')' + s[-1] - отщепнули последний символ и поставили скобочку во внутрь


s = input()
print(rec(s))

# Домашнее задание 1
print('\n Домашнее задание 1:')
# Дана строка, содержащая только английские буквы (большие и маленькие). Добавить символ ‘*’ (звездочка) между буквами
# (перед первой буквой и после последней символ ‘*’ добавлять не нужно).
#
# Входные данные
# Вводится строка ненулевой длины. Известно также, что длина строки не превышает 1000 знаков.
#
# Выходные данные
# Вывести строку, которая получится после добавления символов '*'.
#
# Примеры
# входные данные
# LItBeoFLcSGBOFQxMHoIuDDWcqcVgkcRoAeocXO
# выходные данные
# L*I*t*B*e*o*F*L*c*S*G*B*O*F*Q*x*M*H*o*I*u*D*D*W*c*q*c*V*g*k*c*R*o*A*e*o*c*X*O


# Домашнее задание 2
print('\n Домашнее задание 2:')
# Задачи данного блока можно решить с помощью циклов, однако, рекомендуем попробовать решить их с помощью рекурсивных
# функций, для тренировки.
# Известно, что любой цикл можно заменить рекурсией.
# Дана строка, содержащая только английские буквы (большие и маленькие) и открывающиеся скобки. Сформировать новую
# строку добавлением справа «зеркальной» строки с закрывающимися скобками. "(abc(def(g" -> "(abc(def(gg)fed)cba)"
#
# Входные данные
# Вводится строка ненулевой длины. Известно также, что длина строки не превышает 1000 знаков.
#
# Выходные данные
# Вывести строку, которая получится после "зеркальной" половины строки.
#
# Примеры
# входные данные
# (((t((p((y((kx((((e(((((((vw((v(e((v(m(((h(mlx((s((((d(y((((((((mtk(d(umi((s((sx(p((m(r((kqo
# выходные данные
# (((t((p((y((kx((((e(((((((vw((v(e((v(m(((h(mlx((s((((d(y((((((((mtk(d(umi((s((sx(p((m(r((kqooqk))r)m))p)xs))s))
# imu)d)ktm))))))))y)d))))s))xlm)h)))m)v))e)v))wv)))))))e))))xk))y))p))t)))


# Пример 2
print('\n Пример 2:')


# возводим число 'x' в степень 'n'

def power(x, n):
    if n == 0:
        return 1
    if n < 0:  # если число степени отрицательное
        return 1 / power(x, -n)  # математическое уравнение , 1 поделить на 'x' в противоположной степени
    if n % 2 == 0:  # если число степени четное
        return power(x, n // 2) * power(x, n // 2)  # то 'x' возводим в степень в два раза меньше и перемножаем два икса
    else:  # если число степени не четное
        return power(x, n - 1) * x  # то 'x' умножаем в степень 'n-1' и умножаем на 'x'
    # в итоге опять возвращаемся к началу нашей функции и проверяем раздробленые значения заново, и так пока не
    # выполниться первое условие, а когда оно выполниться мы идем обратно вверх и складываем все полученые результаты


x = int(input())
n = int(input())
print(power(x, n))

# Домашнее задание 2
print('\n Домашнее задание 3:')
# Нумеролог
# (Время: 1 сек. Память: 16 Мб Сложность: 24%)
# Чтобы предсказать судьбу человека, нумеролог берет время жизни человека в секундах, затем складывает все цифры этого
# числа. Если полученное число состоит более чем из одной цифры, операция повторяется, пока в числе не останется одна
# цифра. Затем по полученной цифре и числу операций, необходимых для преобразования числа в цифру нумеролог
# предсказывает судьбу человека. Нумеролог плохо умеет считать, а числа, с которыми он работает, могут быть очень
# большими. Напишите программу, которая бы делала все расчеты за него.
#
# Входные данные
# Входной файл INPUT.TXT содержит число N – время жизни человека в секундах (1 ≤ N ≤ 10 в 1000 степени).
#
# Выходные данные
# В выходной файл OUTPUT.TXT выведите два числа через пробел: полученную цифру из числа N и число преобразований.
#
# Примеры
# №	INPUT.TXT	OUTPUT.TXT
# 1-пример: вход:1, выход: 1 0
# 2-пример: вход:10, выход:1 1
# 3-пример: вход:99, выход:9 2

# Пример 3
print('\n Пример 3:')

a = [1, [3, [4, [3, 4, [6]]], [2, 3, [4]]], 2, [2, 3, 4, [3, 4, [2, 3], 5]]]


# нужно обойти все элементы этого списка и укахать на каком уровне вложенности они находятся

def recc(spisok, level=1):
    # pass  # чтобы оставить функцию пустой
    print(*spisok, 'level=', level)
    for i in spisok:  # пробегаем по всему списку
        if type(i) == list:
            recc(i, level + 1)
        # print(i, type(i)) # выводим элемент и его тип


recc(a)
