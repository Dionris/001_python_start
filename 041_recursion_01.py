# Рекурсия часть 1

# как работает рекурсия
def rec(x):
    if x < 4:
        print(x)
        rec(x + 1)
        print(x)


rec(1)
# вывод :
# 1
# 2
# 3 - рекурсия дойдет до максимального числа 4 , оно его не выведет
# 3 - и вернется к придыдущему
# 2 - и еще к предыдущему
# 1 - чтобы выйти полностью


# Пример
print('\nПример: - Нахождение факториала')


def fact(x):
    if x == 1:  # 'x' не равен 1 значит возвращаем число меньшее на единицу
        return 1  # то возвращаем 1
    return fact(x - 1) * x  # подставляем число 'x' и получаем выражение, потом опять сравниваем 'x==1' если не равен,
    # то подставляем сюда число меньше на единицу и так далее пока 'x' будет равен 1.


# (4-1)*4
# (3-1)*3
# (2-1)*2
# (1-1)*1
# f(4) = f(3)*4 = f(2)*3 = f(1)*2 = {1} => f(1)*{2} => f(2)*{3} => f(3)*{4}
# итого идем обратно мы получим умножаем все в {} => 1*2*3*4=24

print(fact(4))

# Пример
print('\nПример: - Нахождение числа Фибаначи')


def fib(n):
    if n == 1:
        return 0  # возвращаем 0
    if n == 2:
        return 1  # возвращаем 1
    return fib(n - 1) + fib(n - 2)  # сначало м проваливаемся по ветки в самый низ до f(1) и f(0) а потом приплюсовываем
    # и идем вверх полученные значения


print(fib(8))

# Пример
print('\nПример: - является ли строка полиндромом')


# например:
# шалаш
# asdffdsa
# '' - пустая строка
# 'a' - или один символ

def palindrom(s):
    if len(s) <= 1: # если нет, либо есть 1 буква
        return True
    if s[0] != s[-1]: # если первая буква не равна последней то False
        return False
    return palindrom(s[1:-1]) # если первая и последня буква равна они отбрасываются и проверяется заново следующие
    # символы пока не останется 1 или ноль букв


print(palindrom('шалаш'))
print(palindrom('asdffdsa'))
print(palindrom('шалош'))


